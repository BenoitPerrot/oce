// Copyright (c) 1995-1999 Matra Datavision
// Copyright (c) 1999-2014 OPEN CASCADE SAS
//
// This file is part of Open CASCADE Technology software library.
//
// This library is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License version 2.1 as published
// by the Free Software Foundation, with special exception defined in the file
// OCCT_LGPL_EXCEPTION.txt. Consult the file LICENSE_LGPL_21.txt included in OCCT
// distribution for complete text of the license and disclaimer of any warranty.
//
// Alternatively, this file may be used under the terms of Open CASCADE
// commercial license or contractual agreement.

// xab : modified 15-Mar-94 added EvalBSplineMatrix, FactorBandedMatrix, SolveBandedSystem
//                          Eval, BuildCache, cacheD0, cacheD1, cacheD2, cacheD3, LocalMatrix,
//                          EvalPolynomial, RationalDerivatives.
// xab : 22-Mar-94 : fixed rational problem in BuildCache
// xab : 12-Mar-96 : added MovePointAndTangent
#include <TColStd_Array1OfInteger.hxx>
#include <TColStd_Array1OfReal.hxx>
#include <gp_Vec2d.hxx>
#include <Standard_ConstructionError.hxx>
#include <PLib.hxx>
#include <math_Matrix.hxx>

//=======================================================================
//struct : BSplCLib_DataContainer 
//purpose: Auxiliary structure providing buffers for poles and knots used in
//         evaluation of bspline (allocated in the stack)
//=======================================================================

struct BSplCLib_DataContainer 
{
  BSplCLib_DataContainer(Standard_Integer Degree) 
  {
    (void)Degree; // avoid compiler warning
    Standard_OutOfRange_Raise_if (Degree > BSplCLib::MaxDegree() ||
        BSplCLib::MaxDegree() > 25,
        "BSplCLib: bspline degree is greater than maximum supported");
  }

  Standard_Real poles[(25+1)*(Dimension_gen+1)];
  Standard_Real knots[2*25];
  Standard_Real ders[Dimension_gen*4];
};

//
// CURVES MODIFICATIONS
//

//--------------------------------------------------------------------------
//ELEMENTARY COMPUTATIONS
//--------------------------------------------------------------------------
//
// All the following methods are methods of low level used in BSplCLib 
// but also in BSplSLib (but not in Geom)
// At the creation time of this package there is no possibility 
// to declare private methods of package and to declare friend
// methods of package.  It could interesting to declare that BSplSLib
// is a package friend to BSplCLib because it uses all the basis methods
// of BSplCLib.
//--------------------------------------------------------------------------

//=======================================================================
//function : BuildEval
//purpose  : builds the local array for evaluation
//=======================================================================

static void BuildEval(const Standard_Integer Degree,
		      const Standard_Integer Index,
		      const Array1OfPoints& Poles,
		      Standard_Real& LP) {
  Standard_Integer PLower = Poles.Lower();
  Standard_Integer PUpper = Poles.Upper();

  Standard_Integer ip = PLower + Index - 1;
  Standard_Real* pole = &LP;

  for (auto i = 0; i <= Degree; i++) {
    ip++;
    if (ip > PUpper) ip = PLower;
    const Point& P = Poles(ip);
    PointToCoords (pole,P,+0);
    pole += Dimension_gen;
  }
}

static void BuildEval(const Standard_Integer Degree,
		      const Standard_Integer Index,
		      const Array1OfPoints& Poles,
		      const TColStd_Array1OfReal& Weights,
		      Standard_Real& LP) {
  Standard_Integer PLower = Poles.Lower();
  Standard_Integer PUpper = Poles.Upper();

  Standard_Integer ip = PLower + Index - 1;
  Standard_Real* pole = &LP;

  for (auto i = 0; i <= Degree; i++) {
    ip++;
    if (ip > PUpper) ip = PLower;
    const Point& P = Poles(ip);
    Standard_Real w = Weights(ip);
    pole[Dimension_gen] = w;
    PointToCoords (pole, P, * w);
    pole += Dimension_gen + 1;
  }
}

//=======================================================================
//function : PrepareEval
//purpose  : stores data for Eval in the local arrays
//           dc.poles and dc.knots
//=======================================================================

static void PrepareEval
(Standard_Real&                 u,                  
 Standard_Integer&              index, 
 Standard_Integer&              dim,
 Standard_Boolean&              rational,
 const Standard_Integer         Degree,     
 const Standard_Boolean         Periodic,
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 const TColStd_Array1OfReal&    Knots,  
 const TColStd_Array1OfInteger* Mults,
 BSplCLib_DataContainer& dc) 
{
  // Set the Index
  BSplCLib::LocateParameter(Degree,Knots,Mults,u,Periodic,index,u);

  // make the knots
  BSplCLib::BuildKnots(Degree,index,Periodic,Knots,Mults,*dc.knots);
  if (Mults == nullptr)
    index -= Knots.Lower() + Degree;
  else
    index = BSplCLib::PoleIndex(Degree,index,Periodic,*Mults);

  // check truly rational
  rational = (Weights != nullptr);
  if (rational) {
    Standard_Integer WLower = Weights->Lower() + index;
    rational = BSplCLib::IsRational(*Weights, WLower, WLower + Degree);
  }

  // make the poles
  if (rational) {
    dim = Dimension_gen + 1;
    BuildEval(Degree, index, Poles, *Weights, *dc.poles);
  }
  else {
    dim = Dimension_gen; 
    BuildEval(Degree, index, Poles, *dc.poles);
  }
}

//=======================================================================
//function : D0
//purpose  : 
//=======================================================================

void BSplCLib::D0 
(const Standard_Real            U,                  
 const Standard_Integer         Index,          
 const Standard_Integer         Degree,     
 const Standard_Boolean         Periodic,
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 const TColStd_Array1OfReal&    Knots,  
 const TColStd_Array1OfInteger* Mults,  
 Point&                         P) 
{                    
//  Standard_Integer k,dim,index = Index;
  Standard_Integer dim,index = Index;
  Standard_Real    u = U;
  Standard_Boolean rational;
  BSplCLib_DataContainer dc(Degree);
  PrepareEval(u,index,dim,rational,Degree,Periodic,Poles,Weights,Knots,Mults,dc);
  BSplCLib::Eval(u,Degree,*dc.knots,dim,*dc.poles);

  if (rational) {
    Standard_Real w = dc.poles[Dimension_gen];
    CoordsToPoint (P, dc.poles, / w);
  }
  else
    CoordsToPoint (P, dc.poles, );
}

//=======================================================================
//function : D1
//purpose  : 
//=======================================================================

void BSplCLib::D1
(const Standard_Real            U,                  
 const Standard_Integer         Index,          
 const Standard_Integer         Degree,     
 const Standard_Boolean         Periodic,
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 const TColStd_Array1OfReal&    Knots,  
 const TColStd_Array1OfInteger* Mults,  
 Point&                         P,
 Vector&                        V) 
{                    
  Standard_Integer dim,index = Index;
  Standard_Real    u = U;
  Standard_Boolean rational;
  BSplCLib_DataContainer dc(Degree);
  PrepareEval(u,index,dim,rational,Degree,Periodic,Poles,Weights,Knots,Mults,dc);
  BSplCLib::Bohm(u,Degree,1,*dc.knots,dim,*dc.poles);
  Standard_Real *result = dc.poles;
  if (rational) {
    PLib::RationalDerivative(Degree,1,Dimension_gen,*dc.poles,*dc.ders);
    result = dc.ders;
  }
  
  CoordsToPoint (P, result, );
  CoordsToPoint (V, result + Dimension_gen, );
}

//=======================================================================
//function : D2
//purpose  : 
//=======================================================================

void BSplCLib::D2
(const Standard_Real            U,                  
 const Standard_Integer         Index,          
 const Standard_Integer         Degree,     
 const Standard_Boolean         Periodic,
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 const TColStd_Array1OfReal&    Knots,  
 const TColStd_Array1OfInteger* Mults,  
 Point&                         P,
 Vector&                        V1,
 Vector&                        V2) 
{                    
  Standard_Integer dim,index = Index;
  Standard_Real    u = U;
  Standard_Boolean rational;
  BSplCLib_DataContainer dc(Degree);
  PrepareEval(u,index,dim,rational,Degree,Periodic,Poles,Weights,Knots,Mults,dc);
  BSplCLib::Bohm(u,Degree,2,*dc.knots,dim,*dc.poles);
  Standard_Real *result = dc.poles;
  if (rational) {
    PLib::RationalDerivative(Degree,2,Dimension_gen,*dc.poles,*dc.ders);
    result = dc.ders;
  }
  
  CoordsToPoint (P,  result, );
  CoordsToPoint (V1, result + Dimension_gen, );
  if (!rational && (Degree < 2)) 
    NullifyPoint (V2);
  else
    CoordsToPoint (V2, result + 2 * Dimension_gen, );  
}

//=======================================================================
//function : D3
//purpose  : 
//=======================================================================

void BSplCLib::D3
(const Standard_Real            U,                  
 const Standard_Integer         Index,          
 const Standard_Integer         Degree,     
 const Standard_Boolean         Periodic,
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 const TColStd_Array1OfReal&    Knots,  
 const TColStd_Array1OfInteger* Mults,  
 Point&                         P,
 Vector&                        V1,
 Vector&                        V2,
 Vector&                        V3) 
{                    
  Standard_Integer dim,index = Index;
  Standard_Real    u = U;
  Standard_Boolean rational;
  BSplCLib_DataContainer dc(Degree);
  PrepareEval(u,index,dim,rational,Degree,Periodic,Poles,Weights,Knots,Mults,dc);
  BSplCLib::Bohm(u,Degree,3,*dc.knots,dim,*dc.poles);
  Standard_Real *result = dc.poles;
  if (rational) {
    PLib::RationalDerivative(Degree,3,Dimension_gen,*dc.poles,*dc.ders);
    result = dc.ders;
  }

  CoordsToPoint (P,  result, );
  CoordsToPoint (V1, result + Dimension_gen, );
  if (!rational && (Degree < 2)) 
    NullifyPoint (V2);
  else
    CoordsToPoint (V2, result + 2 * Dimension_gen, );  
  if (!rational && (Degree < 3)) 
    NullifyPoint (V3);
  else
    CoordsToPoint (V3, result + 3 * Dimension_gen, );  
}

//=======================================================================
//function : DN
//purpose  : 
//=======================================================================

void BSplCLib::DN
(const Standard_Real            U,                  
 const Standard_Integer         N,          
 const Standard_Integer         Index,          
 const Standard_Integer         Degree,     
 const Standard_Boolean         Periodic,
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 const TColStd_Array1OfReal&    Knots,  
 const TColStd_Array1OfInteger* Mults,  
 Vector&                        VN) 
{                    
  Standard_Integer dim,index = Index;
  Standard_Real    u = U;
  Standard_Boolean rational;
  BSplCLib_DataContainer dc(Degree);
  PrepareEval(u,index,dim,rational,Degree,Periodic,Poles,Weights,Knots,Mults,dc);
  BSplCLib::Bohm(u,Degree,N,*dc.knots,dim,*dc.poles);

  if (rational) {
    Standard_Real v[Dimension_gen];
    PLib::RationalDerivative(Degree,N,Dimension_gen,*dc.poles,v[0],Standard_False);
    CoordsToPoint (VN, v, );
  }
  else {
    if (N > Degree) 
      NullifyPoint (VN);
    else {
      Standard_Real *DN = dc.poles + N * Dimension_gen;
      CoordsToPoint (VN, DN, );
    }
  }
}

//=======================================================================
//function : CacheD0
//purpose  : Evaluates the polynomial cache of the Bspline Curve
//           
//=======================================================================
void  BSplCLib::CacheD0(const Standard_Real                  Parameter,
			const  Standard_Integer               Degree,
			const  Standard_Real                  CacheParameter,
			const  Standard_Real                  SpanLenght,
			const  Array1OfPoints&                PolesArray,
			const  TColStd_Array1OfReal*          WeightsArray,
			Point&                                aPoint)
{
  //
  // the CacheParameter is where the cache polynomial was evaluated in homogeneous
  // form
  // the SpanLenght     is the normalizing factor so that the polynomial is between
  // 0 and 1 
  Standard_Real NewParameter, Inverse;
  Standard_Real * PArray  = (Standard_Real *) &(PolesArray(PolesArray.Lower())) ;
  Standard_Real * myPoint = (Standard_Real *) &aPoint  ;
  NewParameter = (Parameter - CacheParameter) / SpanLenght ; 
  PLib::NoDerivativeEvalPolynomial(NewParameter,
		       Degree,
		       Dimension_gen,
		       Degree * Dimension_gen,
		       PArray[0],
		       myPoint[0]) ;
  if (WeightsArray != nullptr) {
    Standard_Real *
      WArray = (Standard_Real *) &(*WeightsArray)(WeightsArray->Lower()) ;
    PLib::NoDerivativeEvalPolynomial(NewParameter,
			 Degree,
			 1,
			 Degree,
			 WArray[0],
			 Inverse) ;
    
    Inverse = 1.0e0 / Inverse;
    ModifyCoords (myPoint, *= Inverse);
  }
}

//=======================================================================
//function : CacheD1
//purpose  : Evaluates the polynomial cache of the Bspline Curve
//           
//=======================================================================
void  BSplCLib::CacheD1(const Standard_Real                  Parameter,
		        const Standard_Integer                Degree,
                        const  Standard_Real                  CacheParameter,
                        const  Standard_Real                  SpanLenght,
			const  Array1OfPoints&                PolesArray,
			const  TColStd_Array1OfReal*          WeightsArray,
			Point&                                aPoint,
			Vector&                               aVector) 
{
  //
  // the CacheParameter is where the cache polynomial was evaluated in homogeneous
  // form
  // the SpanLenght     is the normalizing factor so that the polynomial is between
  // 0 and 1 
  Standard_Real LocalPDerivatives[Dimension_gen << 1] ;
//  Standard_Real LocalWDerivatives[2], NewParameter, Inverse ;
  Standard_Real LocalWDerivatives[2], NewParameter ;
  
  Standard_Real * 
    PArray = (Standard_Real *) &(PolesArray(PolesArray.Lower())) ;
  Standard_Real *
    myPoint = (Standard_Real *) &aPoint  ;
  Standard_Real *
    myVector = (Standard_Real *) &aVector ;
  NewParameter = (Parameter - CacheParameter) / SpanLenght ; 
  PLib::EvalPolynomial(NewParameter,
		       1,
		       Degree,
		       Dimension_gen,
		       PArray[0],
		       LocalPDerivatives[0]) ;
  // 
  // unormalize derivatives since those are computed normalized
  //

  ModifyCoords (LocalPDerivatives + Dimension_gen, /= SpanLenght);
  
  if (WeightsArray != nullptr) {
    Standard_Real *
      WArray = (Standard_Real *) &(*WeightsArray)(WeightsArray->Lower()) ;
    PLib::EvalPolynomial(NewParameter,
			 1,
			 Degree,
			 1,
			 WArray[0],
			 LocalWDerivatives[0]) ;
    // 
    // unormalize the result since the polynomial stored in the cache
    // is normalized between 0 and 1
    //
    LocalWDerivatives[1] /= SpanLenght ;
    
    PLib::RationalDerivatives(1,
			      Dimension_gen,
			      LocalPDerivatives[0],
			      LocalWDerivatives[0],
			      LocalPDerivatives[0]) ;
  }
  
  CopyCoords (myPoint,  LocalPDerivatives);
  CopyCoords (myVector, LocalPDerivatives + Dimension_gen);
}

//=======================================================================
//function : CacheD2
//purpose  : Evaluates the polynomial cache of the Bspline Curve
//           
//=======================================================================
void  BSplCLib::CacheD2(const Standard_Real                  Parameter,
			const Standard_Integer                Degree,
			const  Standard_Real                  CacheParameter,
			const  Standard_Real                  SpanLenght,
			const  Array1OfPoints&                PolesArray,
			const  TColStd_Array1OfReal*          WeightsArray,
			Point&                                aPoint,
			Vector&                               aVector1, 
			Vector&                               aVector2) 
{
  //
  // the CacheParameter is where the cache polynomial was evaluated in homogeneous
  // form
  // the SpanLenght     is the normalizing factor so that the polynomial is between
  // 0 and 1 
  Standard_Integer ii,Index,EndIndex;
  Standard_Real LocalPDerivatives[(Dimension_gen << 1) + Dimension_gen] ;
//  Standard_Real LocalWDerivatives[3], NewParameter, Factor, Inverse ;
  Standard_Real LocalWDerivatives[3], NewParameter, Factor ;
  Standard_Real * PArray    = (Standard_Real *) &(PolesArray(PolesArray.Lower())) ;
  Standard_Real * myPoint   = (Standard_Real *) &aPoint  ;
  Standard_Real * myVector1 = (Standard_Real *) &aVector1 ;
  Standard_Real * myVector2 = (Standard_Real *) &aVector2 ;
  NewParameter = (Parameter - CacheParameter) / SpanLenght ; 
  PLib::EvalPolynomial(NewParameter,
		       2,
		       Degree,
		       Dimension_gen,
		       PArray[0],
		       LocalPDerivatives[0]) ;
  // 
  // unormalize derivatives since those are computed normalized
  //
  Factor = 1.0e0/ SpanLenght ;
  Index = Dimension_gen ;
  EndIndex = Min (2, Degree) ;

  for (ii = 1 ; ii <= EndIndex ; ii++) {
    ModifyCoords (LocalPDerivatives + Index, *= Factor);
    Factor /= SpanLenght ;
    Index  += Dimension_gen;
  }

  Index = (Degree + 1) * Dimension_gen;
  for (ii = Degree ; ii < 2 ; ii++) {
    NullifyCoords (LocalPDerivatives + Index);
    Index += Dimension_gen;
  }

  if (WeightsArray != nullptr) {
    Standard_Real *
      WArray = (Standard_Real *) &(*WeightsArray)(WeightsArray->Lower()) ;
    
    PLib::EvalPolynomial(NewParameter,
			 2,
			 Degree,
			 1,
			 WArray[0],
			 LocalWDerivatives[0]) ;

    for (ii = Degree + 1  ; ii <= 2 ; ii++) {
      LocalWDerivatives[ii] = 0.0e0 ;
    }
    // 
    // unormalize the result since the polynomial stored in the cache
    // is normalized between 0 and 1
    //
    Factor = 1.0e0 / SpanLenght ;

    for (ii = 1 ; ii <= EndIndex ; ii++) { 
      LocalWDerivatives[ii] *= Factor ;
      Factor /= SpanLenght ;
    }
    PLib::RationalDerivatives(2,
			      Dimension_gen,
			      LocalPDerivatives[0],
			      LocalWDerivatives[0],
			      LocalPDerivatives[0]) ;
  }

  CopyCoords (myPoint,   LocalPDerivatives);
  CopyCoords (myVector1, LocalPDerivatives + Dimension_gen);
  CopyCoords (myVector2, LocalPDerivatives + Dimension_gen * 2);
}

//=======================================================================
//function : CacheD3
//purpose  : Evaluates the polynomial cache of the Bspline Curve
//           
//=======================================================================
void  BSplCLib::CacheD3(const Standard_Real                  Parameter,
			const Standard_Integer                Degree,
			const  Standard_Real                  CacheParameter,
			const  Standard_Real                  SpanLenght,
			const  Array1OfPoints&                PolesArray,
			const  TColStd_Array1OfReal*          WeightsArray,
			Point&                                aPoint,
			Vector&                               aVector1, 
			Vector&                               aVector2,
			Vector&                               aVector3) 
{
  //
  // the CacheParameter is where the cache polynomial was evaluated in homogeneous
  // form
  // the SpanLenght     is the normalizing factor so that the polynomial is between
  // 0 and 1 
  Standard_Integer ii, Index, EndIndex;
  Standard_Real LocalPDerivatives[Dimension_gen << 2] ;
//  Standard_Real LocalWDerivatives[4], Factor, NewParameter, Inverse ;
  Standard_Real LocalWDerivatives[4], Factor, NewParameter ;
  Standard_Real * PArray    = (Standard_Real *) &(PolesArray(PolesArray.Lower())) ;
  Standard_Real * myPoint   = (Standard_Real *) &aPoint  ;
  Standard_Real * myVector1 = (Standard_Real *) &aVector1 ;
  Standard_Real * myVector2 = (Standard_Real *) &aVector2 ;
  Standard_Real * myVector3 = (Standard_Real *) &aVector3 ;
  NewParameter = (Parameter - CacheParameter) / SpanLenght ; 
  PLib::EvalPolynomial(NewParameter,
		       3,
		       Degree,
		       Dimension_gen,
		       PArray[0],
		       LocalPDerivatives[0]) ;

  Index = (Degree + 1) * Dimension_gen;
  for (ii = Degree ; ii < 3 ; ii++) {
    NullifyCoords (LocalPDerivatives + Index);
    Index += Dimension_gen;
  }
  
  // 
  // unormalize derivatives since those are computed normalized
  //
  Factor = 1.0e0 / SpanLenght ;
  Index = Dimension_gen ;
  EndIndex = Min(3,Degree) ;

  for (ii = 1 ; ii <= EndIndex ; ii++) { 
    ModifyCoords (LocalPDerivatives + Index, *= Factor);
    Factor /= SpanLenght;
    Index  += Dimension_gen;
  }
  
  if (WeightsArray != nullptr) {
    Standard_Real *
      WArray = (Standard_Real *) &(*WeightsArray)(WeightsArray->Lower()) ;
    
    PLib::EvalPolynomial(NewParameter,
			 3,
			 Degree,
			 1,
			 WArray[0],
			 LocalWDerivatives[0]) ;
    // 
    // unormalize the result since the polynomial stored in the cache
    // is normalized between 0 and 1
    //
    Factor = 1.0e0 / SpanLenght ;

    for (ii = 1 ; ii <= EndIndex ; ii++) { 
      LocalWDerivatives[ii] *= Factor ;
      Factor /= SpanLenght ;
    }

    for (ii = (Degree + 1)  ; ii <= 3 ; ii++) {
      LocalWDerivatives[ii] = 0.0e0 ;
    }
    PLib::RationalDerivatives(3,
			      Dimension_gen,
			      LocalPDerivatives[0],
			      LocalWDerivatives[0],
			      LocalPDerivatives[0]) ;
  }
  
  CopyCoords (myPoint,   LocalPDerivatives);
  CopyCoords (myVector1, LocalPDerivatives + Dimension_gen);
  CopyCoords (myVector2, LocalPDerivatives + Dimension_gen * 2);
  CopyCoords (myVector3, LocalPDerivatives + Dimension_gen * 3);
}

//=======================================================================
//function : BuildCache
//purpose  : Stores theTaylor expansion normalized between 0,1 in the
//           Cache : in case of  a rational function the Poles are
//           stored in homogeneous form 
//=======================================================================

void BSplCLib::BuildCache
(const Standard_Real            U,   
 const Standard_Real            SpanDomain,    
 const Standard_Boolean         Periodic,
 const Standard_Integer         Degree,     
 const TColStd_Array1OfReal&    FlatKnots,   
 const Array1OfPoints&          Poles,  
 const TColStd_Array1OfReal*    Weights,
 Array1OfPoints&                CachePoles,
 TColStd_Array1OfReal*          CacheWeights)
{                    
  Standard_Integer ii,
  Dimension,
  LocalIndex,
  index = 0 ;
  Standard_Real    u = U,
  LocalValue ;
  Standard_Boolean rational;

  BSplCLib_DataContainer dc(Degree);
  PrepareEval(u,
              index,
              Dimension,
              rational,
              Degree,
              Periodic,
              Poles,
              Weights,
              FlatKnots,
              nullptr,
              dc);
  // 
  // Watch out : PrepareEval checks if locally the Bspline is polynomial
  // therefore rational flag could be set to False even if there are 
  // Weights. The Dimension is set accordingly.
  //
  
  BSplCLib::Bohm(u,Degree,Degree,*dc.knots,Dimension,*dc.poles);
  
  LocalValue = 1.0e0 ;
  LocalIndex = 0 ;

  if (rational) {
 
    for (ii = 1 ; ii <= Degree + 1 ; ii++) {
      CoordsToPoint (CachePoles(ii), dc.poles + LocalIndex, * LocalValue);
      LocalIndex += Dimension_gen + 1;
      LocalValue *= SpanDomain / (Standard_Real) ii ;
    }

    LocalIndex = Dimension_gen;
    LocalValue = 1.0e0 ;      
    for (ii = 1 ; ii <= Degree + 1 ; ii++) {
#warning FIXME: dereferencing CacheWeights without prior checking
      (*CacheWeights)(ii) = dc.poles[LocalIndex] * LocalValue ;
      LocalIndex += Dimension_gen + 1;
      LocalValue *= SpanDomain / (Standard_Real) ii ;
    }
  }
  else {
    
    for (ii = 1 ; ii <= Degree + 1 ; ii++) {
      CoordsToPoint (CachePoles(ii), dc.poles + LocalIndex, * LocalValue);
      LocalIndex += Dimension_gen;
      LocalValue *= SpanDomain / (Standard_Real) ii ;
    }

    if (CacheWeights != nullptr) {
      for (ii = 1 ; ii <= Degree + 1 ; ii++)
	(*CacheWeights)(ii) = 0.0e0 ;
      (*CacheWeights)(1) = 1.0e0 ;
    }
  }
}

